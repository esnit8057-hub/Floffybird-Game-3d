<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Flappy Bird - Neon Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            overflow: hidden;
            background: linear-gradient(#001a33, #002b4d);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
        }

        #gameCanvas {
            display: block;
            max-width: 100%;
            max-height: 100vh;
            border: 3px solid #00ffff;
            box-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Disable back button on mobile
        history.pushState(null, null, location.href);
        window.onpopstate = function () {
            history.go(1);
        };

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size for mobile optimization
        function resizeCanvas() {
            const maxWidth = 400;
            const maxHeight = 600;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            if (windowWidth < maxWidth || windowHeight < maxHeight) {
                canvas.width = Math.min(windowWidth - 20, maxWidth);
                canvas.height = Math.min(windowHeight - 20, maxHeight);
            } else {
                canvas.width = maxWidth;
                canvas.height = maxHeight;
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game variables
        const GRAVITY = 0.2;
        const JUMP_FORCE = -4;
        const PIPE_SPEED = 1;
        const PIPE_GAP = 200;
        const PIPE_WIDTH = 60;
        const GROUND_HEIGHT = 80;
        const MAX_FALL_SPEED = 5;

        let gameState = 'start';
        let score = 0;
        let bestScore = localStorage.getItem('bestScore') || 0;
        let frames = 0;
        let nextPipeFrame = 100;

        // Random pipe colors array
        const pipeColors = [
            { main: '#00ff00', shadow: '#00ff88', stroke: '#00ffff' },  // Green
            { main: '#ff00ff', shadow: '#ff66ff', stroke: '#ff0088' },  // Magenta
            { main: '#00ffff', shadow: '#66ffff', stroke: '#0088ff' },  // Cyan
            { main: '#ffff00', shadow: '#ffff88', stroke: '#ff8800' },  // Yellow
            { main: '#ff0066', shadow: '#ff6699', stroke: '#ff00ff' },  // Pink
            { main: '#0066ff', shadow: '#6699ff', stroke: '#00ffff' },  // Blue
            { main: '#ff6600', shadow: '#ff9966', stroke: '#ffff00' }   // Orange
        ];

        // Bird object with bigger size and clear wings
        const bird = {
            x: 80,
            y: canvas.height / 2,
            radius: 20,              // Increased from 15 to 20
            velocity: 0,
            color: '#FFD700',
            wingAngle: 0,
            wingSpeed: 0.3,
            
            draw() {
                // Animate wings
                this.wingAngle += this.wingSpeed;
                
                // Bird glow effect
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#FFD700';
                
                // Wings - bigger and clearer
                const wingY = Math.sin(this.wingAngle) * 8;
                const wingSize = 18;
                
                // Left wing
                ctx.fillStyle = '#FF8C00';
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(this.x - 12, this.y + wingY, wingSize, 12, -0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Right wing
                ctx.beginPath();
                ctx.ellipse(this.x - 12, this.y - wingY, wingSize, 12, 0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Bird body - bigger
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Bird eye (neon) - bigger
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(this.x + 7, this.y - 4, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye pupil
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(this.x + 8, this.y - 4, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Bird beak - bigger
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff0066';
                ctx.fillStyle = '#ff0066';
                ctx.strokeStyle = '#ff0033';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x + 20, this.y);
                ctx.lineTo(this.x + 28, this.y - 4);
                ctx.lineTo(this.x + 28, this.y + 4);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Reset shadow
                ctx.shadowBlur = 0;
            },
            
            update() {
                this.velocity += GRAVITY;
                
                if (this.velocity > MAX_FALL_SPEED) {
                    this.velocity = MAX_FALL_SPEED;
                }
                
                this.y += this.velocity;
                
                // Ground collision
                if (this.y + this.radius >= canvas.height - GROUND_HEIGHT) {
                    this.y = canvas.height - GROUND_HEIGHT - this.radius;
                    gameState = 'gameOver';
                }
                
                // Ceiling collision
                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocity = 0;
                }
            },
            
            jump() {
                this.velocity = JUMP_FORCE;
                playSound('jump');
            },
            
            reset() {
                this.y = canvas.height / 2;
                this.velocity = 0;
            }
        };

        // Pipes array
        const pipes = [];

        function createPipe() {
            const minHeight = 100;
            const maxHeight = canvas.height - GROUND_HEIGHT - PIPE_GAP - 100;
            const topHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
            
            // Random color for each pipe
            const randomColor = pipeColors[Math.floor(Math.random() * pipeColors.length)];
            
            pipes.push({
                x: canvas.width,
                topHeight: topHeight,
                bottomY: topHeight + PIPE_GAP,
                scored: false,
                color: randomColor
            });
            
            // Random timing for next pipe
            nextPipeFrame = frames + Math.floor(Math.random() * 80) + 100;
        }

        function drawPipes() {
            pipes.forEach(pipe => {
                // Neon glow effect
                ctx.shadowBlur = 20;
                
                // Top pipe with random neon color
                const topGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
                topGradient.addColorStop(0, pipe.color.main);
                topGradient.addColorStop(0.5, pipe.color.shadow);
                topGradient.addColorStop(1, pipe.color.main);
                
                ctx.fillStyle = topGradient;
                ctx.shadowColor = pipe.color.main;
                ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight);
                
                ctx.strokeStyle = pipe.color.stroke;
                ctx.lineWidth = 2;
                ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight);
                
                // Top pipe cap
                ctx.shadowBlur = 30;
                ctx.shadowColor = pipe.color.shadow;
                ctx.fillStyle = pipe.color.shadow;
                ctx.fillRect(pipe.x - 5, pipe.topHeight - 20, PIPE_WIDTH + 10, 20);
                ctx.strokeRect(pipe.x - 5, pipe.topHeight - 20, PIPE_WIDTH + 10, 20);
                
                // Bottom pipe with same random color
                const bottomGradient = ctx.createLinearGradient(pipe.x, pipe.bottomY, pipe.x + PIPE_WIDTH, canvas.height);
                bottomGradient.addColorStop(0, pipe.color.main);
                bottomGradient.addColorStop(0.5, pipe.color.shadow);
                bottomGradient.addColorStop(1, pipe.color.main);
                
                ctx.fillStyle = bottomGradient;
                ctx.shadowColor = pipe.color.main;
                ctx.shadowBlur = 20;
                ctx.fillRect(pipe.x, pipe.bottomY, PIPE_WIDTH, canvas.height - pipe.bottomY - GROUND_HEIGHT);
                ctx.strokeRect(pipe.x, pipe.bottomY, PIPE_WIDTH, canvas.height - pipe.bottomY - GROUND_HEIGHT);
                
                // Bottom pipe cap
                ctx.shadowBlur = 30;
                ctx.shadowColor = pipe.color.shadow;
                ctx.fillStyle = pipe.color.shadow;
                ctx.fillRect(pipe.x - 5, pipe.bottomY, PIPE_WIDTH + 10, 20);
                ctx.strokeRect(pipe.x - 5, pipe.bottomY, PIPE_WIDTH + 10, 20);
                
                // Reset shadow
                ctx.shadowBlur = 0;
            });
        }

        function updatePipes() {
            // Create new pipes at random intervals
            if (frames >= nextPipeFrame) {
                createPipe();
            }
            
            // Move and check pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                pipes[i].x -= PIPE_SPEED;
                
                // Check collision
                if (checkCollision(bird, pipes[i])) {
                    gameState = 'gameOver';
                    playSound('hit');
                }
                
                // Score point
                if (!pipes[i].scored && pipes[i].x + PIPE_WIDTH < bird.x) {
                    pipes[i].scored = true;
                    score++;
                    playSound('score');
                }
                
                // Remove off-screen pipes
                if (pipes[i].x + PIPE_WIDTH < 0) {
                    pipes.splice(i, 1);
                }
            }
        }

        function checkCollision(bird, pipe) {
            const birdLeft = bird.x - bird.radius;
            const birdRight = bird.x + bird.radius;
            const birdTop = bird.y - bird.radius;
            const birdBottom = bird.y + bird.radius;
            
            const pipeLeft = pipe.x;
            const pipeRight = pipe.x + PIPE_WIDTH;
            
            if (birdRight > pipeLeft && birdLeft < pipeRight) {
                if (birdTop < pipe.topHeight || birdBottom > pipe.bottomY) {
                    return true;
                }
            }
            return false;
        }

        // Ground with neon effect
        function drawGround() {
            const groundGradient = ctx.createLinearGradient(0, canvas.height - GROUND_HEIGHT, 0, canvas.height);
            groundGradient.addColorStop(0, '#ff00ff');
            groundGradient.addColorStop(1, '#8800ff');
            
            ctx.fillStyle = groundGradient;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff00ff';
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);
            
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.fillRect(i, canvas.height - GROUND_HEIGHT, 10, 5);
            }
            
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - GROUND_HEIGHT);
            ctx.lineTo(canvas.width, canvas.height - GROUND_HEIGHT);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
        }

        // Back button in top-left corner
        function drawBackButton() {
            const buttonSize = 40;
            const padding = 10;
            
            // Button background
            ctx.fillStyle = 'rgba(255, 0, 102, 0.8)';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff0066';
            ctx.beginPath();
            ctx.arc(padding + buttonSize/2, padding + buttonSize/2, buttonSize/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Back arrow
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#fff';
            
            const centerX = padding + buttonSize/2;
            const centerY = padding + buttonSize/2;
            
            // Arrow line
            ctx.beginPath();
            ctx.moveTo(centerX + 8, centerY);
            ctx.lineTo(centerX - 8, centerY);
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(centerX - 8, centerY);
            ctx.lineTo(centerX - 2, centerY - 6);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX - 8, centerY);
            ctx.lineTo(centerX - 2, centerY + 6);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
        }

        // Score display
        function drawScore() {
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 4;
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText(score, canvas.width / 2, 50);
            ctx.fillText(score, canvas.width / 2, 50);
            ctx.shadowBlur = 0;
        }

        // Start screen
        function drawStartScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.shadowBlur = 40;
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = '#ff00ff';
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 4;
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText('FLAPPY BIRD', canvas.width / 2, canvas.height / 2 - 50);
            ctx.fillText('FLAPPY BIRD', canvas.width / 2, canvas.height / 2 - 50);
            
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            ctx.strokeStyle = '#ff00ff';
            ctx.font = 'bold 25px Arial';
            ctx.strokeText('TAP TO START', canvas.width / 2, canvas.height / 2 + 20);
            ctx.fillText('TAP TO START', canvas.width / 2, canvas.height / 2 + 20);
            
            ctx.font = 'bold 20px Arial';
            ctx.fillText(`Best Score: ${bestScore}`, canvas.width / 2, canvas.height / 2 + 60);
            ctx.shadowBlur = 0;
        }

        // Game over screen
        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.shadowBlur = 40;
            ctx.shadowColor = '#ff0066';
            ctx.fillStyle = '#ff0066';
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 4;
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.strokeText('GAME OVER', canvas.width / 2, canvas.height / 2 - 60);
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 60);
            
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 30px Arial';
            ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2);
            ctx.fillText(`Best: ${bestScore}`, canvas.width / 2, canvas.height / 2 + 40);
            
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 25px Arial';
            ctx.strokeText('TAP TO RESTART', canvas.width / 2, canvas.height / 2 + 90);
            ctx.fillText('TAP TO RESTART', canvas.width / 2, canvas.height / 2 + 90);
            ctx.shadowBlur = 0;
        }

        // Sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                if (type === 'jump') {
                    oscillator.frequency.value = 300;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } else if (type === 'score') {
                    oscillator.frequency.value = 500;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                } else if (type === 'hit') {
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.value = 100;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                }
            } catch (e) {
                // Audio not supported
            }
        }

        // Reset game
        function resetGame() {
            bird.reset();
            pipes.length = 0;
            score = 0;
            frames = 0;
            nextPipeFrame = 100;
            gameState = 'playing';
        }

        // Check if back button is clicked
        function isBackButtonClicked(x, y) {
            const buttonSize = 40;
            const padding = 10;
            const centerX = padding + buttonSize/2;
            const centerY = padding + buttonSize/2;
            const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            return distance <= buttonSize/2;
        }

        // Input handling
        function handleInput(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            
            // Check if back button clicked
            if (isBackButtonClicked(x, y)) {
                if (confirm('Do you want to exit the game?')) {
                    window.history.back();
                }
                return;
            }
            
            if (gameState === 'start') {
                resetGame();
            } else if (gameState === 'playing') {
                bird.jump();
            } else if (gameState === 'gameOver') {
                resetGame();
            }
        }

        canvas.addEventListener('touchstart', handleInput);
        canvas.addEventListener('click', handleInput);

        // Main game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dark neon background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#001a33');
            gradient.addColorStop(0.5, '#002b4d');
            gradient.addColorStop(1, '#003366');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawGround();
            
            if (gameState === 'playing') {
                frames++;
                bird.update();
                updatePipes();
                drawPipes();
                bird.draw();
                drawScore();
                drawBackButton();
                
                if (score > bestScore) {
                    bestScore = score;
                    localStorage.setItem('bestScore', bestScore);
                }
            } else if (gameState === 'start') {
                bird.draw();
                drawStartScreen();
                drawBackButton();
            } else if (gameState === 'gameOver') {
                drawPipes();
                bird.draw();
                drawScore();
                drawGameOverScreen();
                drawBackButton();
                
                if (score > bestScore) {
                    bestScore = score;
                    localStorage.setItem('bestScore', bestScore);
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>